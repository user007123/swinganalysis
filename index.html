<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hover Greens Studio — Dual-Cam Swing Analysis</title>
<style>
  :root{
    --bg:#0b0f14; --fg:#eaf0f6; --muted:#a6b0bd; --brand:#19d47a; --panel:#131a22; --border:rgba(255,255,255,.08);
    --stroke:#ff4b4b;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;}
  a{color:var(--brand)}
  .wrap{max-width:1200px;margin:0 auto;padding:24px}
  header.hero{padding:28px 0 10px}
  .tag{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid var(--border);border-radius:999px;
       background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.01)); color:var(--muted); font-weight:700; font-size:12px; letter-spacing:.3px; text-transform:uppercase}
  h1{font-size: clamp(28px, 4.5vw, 44px); line-height:1.1; margin:10px 0}
  .sub{color:var(--muted); font-size:clamp(15px,1.5vw,18px)}
  .cta-row{display:flex;flex-wrap:wrap;gap:12px;margin-top:14px}
  .btn{border:1px solid var(--border); background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02));
       color:var(--fg); padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer}
  .btn.primary{background:linear-gradient(90deg,var(--brand),#4aa8ff); border:none}
  .btn.danger{background:linear-gradient(90deg,#ff5964,#ff8c5a); border:none}
  .pill{padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:rgba(255,255,255,.02)}
  .panels{display:grid; grid-template-columns:1fr 1fr; gap:16px}
  @media (max-width: 960px){ .panels{grid-template-columns:1fr} }
  .panel{background:var(--panel); border:1px solid var(--border); border-radius:14px; overflow:hidden; position:relative}
  .panel header{display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid var(--border); background:rgba(255,255,255,.02)}
  .panel header .ttl{font-weight:800}
  .slot{position:relative; aspect-ratio:16/9; background:#0b0e13}
  video{width:100%; height:100%; object-fit:contain; background:#000}
  /* FIX: allow drawing on top of video */
  canvas.overlay{position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:auto; z-index:2}
  .panel footer{padding:10px 12px; border-top:1px solid var(--border); background:rgba(255,255,255,.02)}
  .tools, .global{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
  .tiny{font-size:12px; color:var(--muted)}
  .divider{height:1px; background:var(--border); margin:18px 0}
  input[type="range"]{accent-color:#4aa8ff}
  select{background:rgba(255,255,255,.03); color:var(--fg); border:1px solid var(--border); border-radius:8px; padding:6px}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0f1420; border:1px solid var(--border); padding:2px 6px; border-radius:6px}
</style>
</head>
<body>
  <div class="wrap">
    <header class="hero">
      <span class="tag">Hover Greens Studio</span>
      <h1>Dual-camera recording, synced playback, and on-video drawing.</h1>
      <p class="sub">Record both angles at once and auto-play them together. Draw red <b>lines</b> and <b>circles</b> directly on video — drawings persist during playback.</p>
      <div class="cta-row">
        <button class="btn primary" id="ctaStart">Start Now</button>
        <span class="tiny">Shortcuts: <span class="kbd">Space</span> Play/Pause • <span class="kbd">,</span>/<span class="kbd">.</span> frame step • Hold <span class="kbd">C</span> to draw circle</span>
      </div>
    </header>

    <section class="panel">
      <header>
        <span class="ttl">Global Controls</span>
        <div class="global">
          <label class="pill">Playback&nbsp;<input id="rate" type="range" min="0.1" max="1.0" step="0.05" value="0.35" /></label>
          <button class="btn" id="btnSync">Play/Pause Both</button>
          <button class="btn" id="btnBack">◀︎ Frame</button>
          <button class="btn" id="btnFwd">Frame ▶︎</button>
          <button class="btn" id="btnClearAll">Clear All Drawings</button>
        </div>
      </header>
      <footer><span class="tiny">Drag to draw a <b>line</b>. Hold <span class="kbd">C</span> while dragging to draw a <b>circle</b>. Hold <span class="kbd">Shift</span> to lock line H/V.</span></footer>
    </section>

    <section class="panels" id="panelGrid">
      <!-- Left -->
      <div class="panel" data-role="player" id="panelA">
        <header>
          <span class="ttl">Angle A</span>
          <div class="tools">
            <label class="btn">Upload<input type="file" accept="video/*" hidden class="file"></label>
            <select class="cameraSel" title="Select Camera A"></select>
            <button class="btn" data-cam>Use Camera</button>
            <span class="pill tiny">Playback <span class="rate">1.0x</span></span>
          </div>
        </header>
        <div class="slot">
          <video class="vid" playsinline></video>
          <canvas class="overlay"></canvas>
        </div>
        <footer>
          <div class="tools">
            <div class="group">
              <button class="btn" data-play>Play</button>
              <button class="btn" data-pause>Pause</button>
              <button class="btn" data-back>◀︎ Frame</button>
              <button class="btn" data-fwd>Frame ▶︎</button>
            </div>
            <div class="group">
              <label class="pill">Rate <input type="range" min="0.1" max="1.0" step="0.05" value="0.35" data-rate></label>
              <button class="btn" data-clear>Clear</button>
            </div>
          </div>
        </footer>
      </div>

      <!-- Right -->
      <div class="panel" data-role="player" id="panelB">
        <header>
          <span class="ttl">Angle B</span>
          <div class="tools">
            <label class="btn">Upload<input type="file" accept="video/*" hidden class="file"></label>
            <select class="cameraSel" title="Select Camera B"></select>
            <button class="btn" data-cam>Use Camera</button>
            <span class="pill tiny">Playback <span class="rate">1.0x</span></span>
          </div>
        </header>
        <div class="slot">
          <video class="vid" playsinline></video>
          <canvas class="overlay"></canvas>
        </div>
        <footer>
          <div class="tools">
            <div class="group">
              <button class="btn" data-play>Play</button>
              <button class="btn" data-pause>Pause</button>
              <button class="btn" data-back>◀︎ Frame</button>
              <button class="btn" data-fwd>Frame ▶︎</button>
            </div>
            <div class="group">
              <label class="pill">Rate <input type="range" min="0.1" max="1.0" step="0.05" value="0.35" data-rate></label>
              <button class="btn" data-clear>Clear</button>
            </div>
          </div>
        </footer>
      </div>
    </section>

    <div class="divider"></div>

    <section class="panel">
      <header>
        <span class="ttl">Simultaneous Recording</span>
        <div class="tools">
          <label class="pill"><input type="checkbox" id="autoPlayAfter" checked /> Auto-play after record</label>
          <label class="pill"><input type="checkbox" id="autoLoop" checked /> Loop playback</label>
          <label class="pill">Max Duration (s)
            <input type="number" id="maxDur" min="1" max="120" value="8" style="width:70px;background:transparent;color:var(--fg);border:none;outline:none;text-align:center">
          </label>
          <button class="btn primary" id="recordBoth">● Record Both</button>
          <button class="btn danger" id="stopBoth" disabled>■ Stop</button>
          <span class="tiny" id="recStatus">Not recording</span>
        </div>
      </header>
    </section>
  </div>

<script>
(function(){
  const $ = (sel, el=document)=>el.querySelector(sel);
  const $$ = (sel, el=document)=>[...el.querySelectorAll(sel)];
  const clamp = (v,min,max)=>Math.min(max,Math.max(min,v));

  // Globals
  const globalRate = $('#rate');
  const btnSync = $('#btnSync'), btnBack=$('#btnBack'), btnFwd=$('#btnFwd');
  const btnClearAll = $('#btnClearAll');
  const recordBtn = $('#recordBoth'), stopBtn = $('#stopBoth'), recStatus = $('#recStatus');
  const autoPlayAfter = $('#autoPlayAfter'), autoLoop = $('#autoLoop'), maxDur = $('#maxDur');
  const panelGrid = $('#panelGrid');

  function timeStep(video, dir=+1){
    const step = 1/60;
    video.pause();
    video.currentTime = clamp(video.currentTime + dir*step, 0, video.duration || 1e9);
  }

  async function listCameras(){
    try{
      // Pre-prompt permission so labels are visible
      await navigator.mediaDevices.getUserMedia({video:true, audio:false}).then(s=>s.getTracks().forEach(tr=>tr.stop())).catch(()=>{});
      const devices = await navigator.mediaDevices.enumerateDevices();
      return devices.filter(d=>d.kind==='videoinput');
    }catch(e){ console.warn(e); return []; }
  }
  function populateCameraDropdowns(){
    listCameras().then(cams=>{
      $$('.cameraSel').forEach((sel,i)=>{
        sel.innerHTML = '';
        cams.forEach((c, idx)=>{
          const opt = document.createElement('option');
          opt.value = c.deviceId;
          opt.textContent = c.label || `Camera ${idx+1}`;
          sel.appendChild(opt);
        });
        if(cams.length) sel.value = cams[Math.min(i, cams.length-1)].deviceId;
      });
    });
  }

  // ---- Drawing helpers (LINES + CIRCLES, red, no fill)
  function drawingLayer(overlay){
    const ctx = overlay.getContext('2d');
    const state = {
      shapes: [], // {type:'line', a:{x,y}, b:{x,y}} | {type:'circle', c:{x,y}, r}
      active: null, // temp drawing
      keys: {c:false, shift:false}
    };
    const stroke = getComputedStyle(document.documentElement).getPropertyValue('--stroke') || '#ff4b4b';

    function resize(){
      const r = overlay.getBoundingClientRect();
      overlay.width = Math.max(2, Math.floor(r.width));
      overlay.height = Math.max(2, Math.floor(r.height));
      redraw();
    }
    const ro = new ResizeObserver(resize); ro.observe(overlay);

    function redraw(){
      ctx.clearRect(0,0,overlay.width,overlay.height);
      ctx.lineWidth = 3; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle = stroke;

      // Draw saved shapes
      for(const s of state.shapes){
        if(s.type==='line'){
          ctx.beginPath(); ctx.moveTo(s.a.x, s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
        }else if(s.type==='circle'){
          ctx.beginPath(); ctx.arc(s.c.x, s.c.y, s.r, 0, Math.PI*2); ctx.stroke();
        }
      }
      // Active preview
      const s = state.active;
      if(s){
        ctx.setLineDash([8,6]);
        if(s.type==='line'){
          ctx.beginPath(); ctx.moveTo(s.a.x, s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();
        }else if(s.type==='circle'){
          ctx.beginPath(); ctx.arc(s.c.x, s.c.y, s.r, 0, Math.PI*2); ctx.stroke();
        }
        ctx.setLineDash([]);
      }
    }

    function px(ev){
      const r = overlay.getBoundingClientRect();
      const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
      const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
      return {
        x: (clientX - r.left) / r.width * overlay.width,
        y: (clientY - r.top) / r.height * overlay.height
      };
    }
    function onDown(ev){
      ev.preventDefault();
      const p = px(ev);
      if(state.keys.c){
        // start circle
        state.active = {type:'circle', c:p, r:0};
      }else{
        // start line
        state.active = {type:'line', a:p, b:p};
      }
      redraw();
    }
    function onMove(ev){
      if(!state.active) return;
      const p = px(ev);
      if(state.active.type==='line'){
        let a = state.active.a;
        let b = p;
        if(state.keys.shift){
          // lock to H/V depending on stronger axis
          const dx = Math.abs(p.x - a.x), dy = Math.abs(p.y - a.y);
          if(dx > dy){ b = {x:p.x, y:a.y}; } else { b = {x:a.x, y:p.y}; }
        }
        state.active.b = b;
      }else if(state.active.type==='circle'){
        const dx = p.x - state.active.c.x, dy = p.y - state.active.c.y;
        state.active.r = Math.hypot(dx, dy);
      }
      redraw();
    }
    function onUp(ev){
      if(!state.active) return;
      if(state.active.type==='line'){
        // ignore tiny clicks
        const {a,b} = state.active;
        if(Math.hypot(a.x-b.x, a.y-b.y) > 2) state.shapes.push({type:'line', a, b});
      }else if(state.active.type==='circle'){
        if(state.active.r > 1) state.shapes.push({type:'circle', c:state.active.c, r:state.active.r});
      }
      state.active = null;
      redraw();
    }
    function clear(){ state.shapes.length = 0; state.active=null; redraw(); }

    function onKey(e, down){
      if(e.key==='c' || e.key==='C'){ state.keys.c = down; }
      if(e.key==='Shift'){ state.keys.shift = down; }
    }
    window.addEventListener('keydown', e=>onKey(e,true));
    window.addEventListener('keyup', e=>onKey(e,false));

    overlay.addEventListener('pointerdown', onDown);
    overlay.addEventListener('pointermove', onMove);
    overlay.addEventListener('pointerup', onUp);
    overlay.addEventListener('pointerleave', onUp);
    overlay.addEventListener('touchstart', onDown, {passive:false});
    overlay.addEventListener('touchmove', onMove, {passive:false});
    overlay.addEventListener('touchend', onUp);

    resize();
    return {clear, redraw, state};
  }

  // ---- Panel init
  function initPanel(panel){
    const video = $('.vid', panel);
    const overlay = $('.overlay', panel);
    const rateLabel = $('.rate', panel);
    const rateSlider = $('[data-rate]', panel);
    const file = $('.file', panel);
    const btnPlay = $('[data-play]', panel);
    const btnPause = $('[data-pause]', panel);
    const btnBack = $('[data-back]', panel);
    const btnFwd = $('[data-fwd]', panel);
    const btnCam = $('[data-cam]', panel);
    const camSel = $('.cameraSel', panel);

    const drawAPI = drawingLayer(overlay);

    // Upload
    file?.addEventListener('change', e=>{
      const f = e.target.files[0]; if(!f) return;
      const url = URL.createObjectURL(f);
      video.srcObject = null; video.src = url; video.load();
      video.loop = autoLoop.checked;
    });

    // Camera preview
    let currentStream = null;
    async function startCam(){
      try{
        const id = camSel?.value;
        const constraints = {video: id ? {deviceId: {exact:id}, width:{ideal:1920}, height:{ideal:1080}} : {width:{ideal:1920},height:{ideal:1080}}, audio:false};
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        if(currentStream) currentStream.getTracks().forEach(t=>t.stop());
        currentStream = stream;
        video.srcObject = stream; video.muted = true; await video.play();
        panel.__player.stream = stream;
      }catch(err){ console.error(err); alert('Camera not available or permission denied.'); }
    }
    btnCam?.addEventListener('click', startCam);

    // Controls
    btnPlay.addEventListener('click', ()=>video.play());
    btnPause.addEventListener('click', ()=>video.pause());
    btnBack.addEventListener('click', ()=>timeStep(video, -1));
    btnFwd.addEventListener('click', ()=>timeStep(video, +1));

    // Rates
    rateSlider.addEventListener('input', ()=>{
      video.playbackRate = parseFloat(rateSlider.value);
      rateLabel.textContent = video.playbackRate.toFixed(2)+'x';
    });
    const applyGlobalRate = ()=>{ const r = parseFloat(globalRate.value); video.playbackRate = r; rateSlider.value = r; rateLabel.textContent = r.toFixed(2)+'x'; };
    applyGlobalRate();

    // Expose
    panel.__player = {
      video, overlay, drawAPI, stream:null,
      setRate:(r)=>{ video.playbackRate=r; rateSlider.value=r; rateLabel.textContent=r.toFixed(2)+'x'; },
      step:(d)=>timeStep(video,d),
      startCam, camSel
    };

    $('[data-clear]', panel).addEventListener('click', ()=>drawAPI.clear());
  }

  // Init panels
  $$('.panel[data-role="player"]').forEach(initPanel);
  populateCameraDropdowns();

  // Global controls
  globalRate.addEventListener('input', ()=>{
    const r = parseFloat(globalRate.value);
    $$('.panel[data-role="player"]').forEach(p=>p.__player?.setRate(r));
  });
  btnSync.addEventListener('click', ()=>{
    const vids = $$('.panel[data-role="player"] .vid');
    const playAll = vids.some(v=>v.paused);
    vids.forEach(v=> playAll ? v.play() : v.pause());
  });
  btnBack.addEventListener('click', ()=>{$$('.panel[data-role="player"]').forEach(p=>p.__player?.step(-1));});
  btnFwd.addEventListener('click', ()=>{$$('.panel[data-role="player"]').forEach(p=>p.__player?.step(+1));});
  btnClearAll.addEventListener('click', ()=>{$$('.panel[data-role="player"]').forEach(p=>p.__player?.drawAPI.clear());});
  $('#ctaStart').addEventListener('click', ()=>panelGrid.scrollIntoView({behavior:'smooth'}));

  // ---- Simultaneous recording
  let recA=null, recB=null, chunksA=[], chunksB=[], recTimer=null;
  async function ensurePreviewStreams(){
    const panels = [$('#panelA'), $('#panelB')];
    for(const p of panels){
      if(!p.__player.stream){ await p.__player.startCam(); }
    }
  }
  function makeRecorder(stream, ondata){
    const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' :
                 MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' : 'video/webm';
    const rec = new MediaRecorder(stream, {mimeType:mime, videoBitsPerSecond: 6_000_000});
    rec.ondataavailable = e=>{ if(e.data && e.data.size) ondata(e.data); };
    return rec;
  }
  function setRecUI(active){
    recordBtn.disabled = active;
    stopBtn.disabled = !active;
    recStatus.textContent = active ? 'Recording…' : 'Not recording';
  }

  async function startBoth(){
    await ensurePreviewStreams();
    const pA = $('#panelA').__player, pB = $('#panelB').__player;
    chunksA=[]; chunksB=[];
    recA = makeRecorder(pA.stream, d=>chunksA.push(d));
    recB = makeRecorder(pB.stream, d=>chunksB.push(d));
    recA.start(); recB.start();
    setRecUI(true);
    const dur = clamp(parseFloat(maxDur.value)||8, 1, 120);
    recTimer = setTimeout(stopBoth, dur*1000);
  }

  function blobToVideo(video, blob){
    const url = URL.createObjectURL(blob);
    video.srcObject = null;
    video.src = url;
    video.loop = autoLoop.checked;
    video.load();
  }

  function syncAndPlay(){
    const vA = $('#panelA').__player.video;
    const vB = $('#panelB').__player.video;
    const startWhenReady = ()=>{
      if(Number.isFinite(vA.duration) && vA.duration>0 && Number.isFinite(vB.duration) && vB.duration>0){
        vA.currentTime = 0; vB.currentTime = 0;
        const r = parseFloat(globalRate.value);
        vA.playbackRate=r; vB.playbackRate=r;
        if(autoPlayAfter.checked){ vA.play(); vB.play(); }
      }else{
        setTimeout(startWhenReady, 60);
      }
    };
    startWhenReady();
  }

  function stopBoth(){
    try{ recA && recA.state!=='inactive' && recA.stop(); }catch{}
    try{ recB && recB.state!=='inactive' && recB.stop(); }catch{}
    clearTimeout(recTimer); recTimer=null;
    setRecUI(false);

    const done = {};
    const tryFinish = ()=>{
      if(done.a && done.b){
        const vA = $('#panelA').__player.video;
        const vB = $('#panelB').__player.video;
        const blobA = new Blob(chunksA, {type: chunksA[0]?.type || 'video/webm'});
        const blobB = new Blob(chunksB, {type: chunksB[0]?.type || 'video/webm'});
        blobToVideo(vA, blobA);
        blobToVideo(vB, blobB);
        syncAndPlay();
      }
    };
    if(recA) recA.onstop = ()=>{ done.a=true; tryFinish(); };
    if(recB) recB.onstop = ()=>{ done.b=true; tryFinish(); };
  }

  recordBtn.addEventListener('click', startBoth);
  stopBtn.addEventListener('click', stopBoth);

  // Keyboard shortcuts
  document.addEventListener('keydown', (e)=>{
    if(e.target && ['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;
    if(e.code==='Space'){ e.preventDefault(); btnSync.click(); }
    if(e.key===',' ){ e.preventDefault(); btnBack.click(); }
    if(e.key==='.' ){ e.preventDefault(); btnFwd.click(); }
  });
})();
</script>
</body>
</html>
