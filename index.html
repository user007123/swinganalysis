<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hover Greens Studio — Dual-Cam Swing Analysis</title>
<style>
  :root{
    --bg:#000000;           /* matte black */
    --panel:#0A0A0A;        /* panel matte */
    --fg:#FFFFFF;           /* white text */
    --muted:#CCCCCC;        /* subtle gray */
    --border:#1a1a1a;       /* low-contrast border */
    --accent:#1E7030;       /* luxurious forest green */
    --stroke:#ff4b4b;       /* red drawing color */
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;}
  a{color:var(--accent); text-decoration:none}
  .wrap{max-width:1200px;margin:0 auto;padding:24px}
  header.hero{display:flex;align-items:center;justify-content:space-between;gap:16px;padding:8px 0 16px}
  .brand{
    font-weight:900; letter-spacing:.5px; font-size:20px; display:flex; align-items:center; gap:10px;
  }
  .brand .dot{width:10px;height:10px;border-radius:50%;background:var(--accent)}
  .tag{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid var(--border);border-radius:999px;
       background:#0A0A0A; color:var(--muted); font-weight:700; font-size:12px; letter-spacing:.3px; text-transform:uppercase}
  h1{font-size: clamp(26px, 4.2vw, 40px); line-height:1.1; margin:6px 0 8px}
  .sub{color:var(--muted); font-size:clamp(14px,1.4vw,17px)}
  .cta-row{display:flex;flex-wrap:wrap;gap:12px;margin-top:10px}
  .btn{
    border:1px solid var(--border);
    background:#000;
    color:var(--fg);
    padding:10px 14px;
    border-radius:10px;
    font-weight:700; cursor:pointer;
    transition: background-color .15s ease, color .15s ease, border-color .15s ease;
  }
  .btn:hover{ background:var(--accent); color:#fff; border-color:var(--accent) }
  .btn.flat-green{ background:var(--accent); border-color:var(--accent); }
  .btn.flat-green:hover{ background:#155324; border-color:#155324; }
  .btn.danger{ background:#ff4b4b; border-color:#ff4b4b; color:#000 }
  .btn.danger:hover{ background:#c83c3c; border-color:#c83c3c; color:#fff }
  .pill{padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:#000; color:var(--muted)}
  .panels{display:grid; grid-template-columns:1fr 1fr; gap:16px}
  @media (max-width: 960px){ .panels{grid-template-columns:1fr} }
  .panel{background:var(--panel); border:1px solid var(--border); border-radius:14px; overflow:hidden; position:relative}
  .panel header{display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid var(--border);}
  .panel header .ttl{font-weight:800}
  .panel header .tools{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .slot{position:relative; aspect-ratio:16/9; background:#000}
  video{width:100%; height:100%; object-fit:contain; background:#000}
  /* Drawing overlay ON TOP of video */
  canvas.overlay{position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:auto; z-index:2}
  .panel footer{padding:10px 12px; border-top:1px solid var(--border);}
  .tools, .global{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
  .tiny{font-size:12px; color:var(--muted)}
  .divider{height:1px; background:var(--border); margin:18px 0}
  input[type="range"]{
    appearance:none; height:4px; background:#1a1a1a; border-radius:999px; outline:none; width:160px;
  }
  input[type="range"]::-webkit-slider-thumb{
    appearance:none; width:14px; height:14px; border-radius:50%; background:var(--accent); cursor:pointer; border:none;
  }
  select{
    background:#000; color:var(--fg); border:1px solid var(--border); border-radius:8px; padding:6px;
  }
  input[type="number"]{
    background:#000; color:var(--fg); border:1px solid var(--border); border-radius:8px; padding:6px; width:70px; text-align:center;
  }
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0A0A0A; border:1px solid var(--border); padding:2px 6px; border-radius:6px}
</style>
</head>
<body>
  <div class="wrap">
    <header class="hero">
      <div class="brand"><span class="dot"></span>Hover Greens Studio</div>
      <span class="tag">Matte • Minimal • Pro</span>
    </header>

    <section>
      <h1>Dual-camera recording, synced playback, and on-video drawing.</h1>
      <p class="sub">Record either angle or both together. Draw <b style="color:#ff4b4b">red lines & circles</b> directly over the videos — drawings persist while playing back.</p>
      <div class="cta-row">
        <button class="btn flat-green" id="ctaStart">Start Now</button>
        <span class="tiny">Tips: <span class="kbd">Space</span> Play/Pause • <span class="kbd">,</span>/<span class="kbd">.</span> frame step</span>
      </div>
    </section>

    <section class="panel" style="margin-top:14px">
      <header>
        <span class="ttl">Global Controls</span>
        <div class="global">
          <label class="pill">Playback&nbsp;<input id="rate" type="range" min="0.1" max="1.0" step="0.05" value="0.35" /></label>
          <button class="btn" id="btnSync">Play/Pause Both</button>
          <button class="btn" id="btnBack">◀︎ Frame</button>
          <button class="btn" id="btnFwd">Frame ▶︎</button>
          <label class="pill"><input type="checkbox" id="autoLoop" checked /> Loop playback</label>
        </div>
      </header>
    </section>

    <section class="panels" id="panelGrid">
      <!-- Panel A -->
      <div class="panel" data-role="player" id="panelA">
        <header>
          <span class="ttl">Angle A</span>
          <div class="tools">
            <label class="btn">Upload<input type="file" accept="video/*" hidden class="file"></label>
            <select class="cameraSel" title="Select Camera A"></select>
            <button class="btn" data-cam>Use Camera</button>
            <span class="pill tiny">Playback <span class="rate">1.0x</span></span>
          </div>
        </header>
        <div class="slot">
          <video class="vid" playsinline></video>
          <canvas class="overlay"></canvas>
        </div>
        <footer>
          <div class="tools">
            <div class="group">
              <button class="btn" data-play>Play</button>
              <button class="btn" data-pause>Pause</button>
              <button class="btn" data-back>◀︎ Frame</button>
              <button class="btn" data-fwd>Frame ▶︎</button>
              <button class="btn" data-clear>Clear Drawings</button>
            </div>
            <div class="group">
              <label class="pill">Rate <input type="range" min="0.1" max="1.0" step="0.05" value="0.35" data-rate></label>
              <label class="pill">Draw
                <select class="drawMode">
                  <option value="off">Off</option>
                  <option value="line">Line</option>
                  <option value="circle">Circle</option>
                </select>
              </label>
              <button class="btn" data-rec>● Record</button>
              <button class="btn danger" data-stop disabled>■ Stop</button>
              <span class="tiny recStatus">Idle</span>
            </div>
          </div>
        </footer>
      </div>

      <!-- Panel B -->
      <div class="panel" data-role="player" id="panelB">
        <header>
          <span class="ttl">Angle B</span>
          <div class="tools">
            <label class="btn">Upload<input type="file" accept="video/*" hidden class="file"></label>
            <select class="cameraSel" title="Select Camera B"></select>
            <button class="btn" data-cam>Use Camera</button>
            <span class="pill tiny">Playback <span class="rate">1.0x</span></span>
          </div>
        </header>
        <div class="slot">
          <video class="vid" playsinline></video>
          <canvas class="overlay"></canvas>
        </div>
        <footer>
          <div class="tools">
            <div class="group">
              <button class="btn" data-play>Play</button>
              <button class="btn" data-pause>Pause</button>
              <button class="btn" data-back>◀︎ Frame</button>
              <button class="btn" data-fwd>Frame ▶︎</button>
              <button class="btn" data-clear>Clear Drawings</button>
            </div>
            <div class="group">
              <label class="pill">Rate <input type="range" min="0.1" max="1.0" step="0.05" value="0.35" data-rate></label>
              <label class="pill">Draw
                <select class="drawMode">
                  <option value="off">Off</option>
                  <option value="line">Line</option>
                  <option value="circle">Circle</option>
                </select>
              </label>
              <button class="btn" data-rec>● Record</button>
              <button class="btn danger" data-stop disabled>■ Stop</button>
              <span class="tiny recStatus">Idle</span>
            </div>
          </div>
        </footer>
      </div>
    </section>

    <div class="divider"></div>

    <section class="panel">
      <header>
        <span class="ttl">Record Both (Sync)</span>
        <div class="tools">
          <label class="pill">Max Duration (s)
            <input type="number" id="maxDur" min="1" max="120" value="8">
          </label>
          <label class="pill"><input type="checkbox" id="autoPlayAfter" checked /> Auto-play after record</label>
          <button class="btn flat-green" id="recordBoth">● Record Both</button>
          <button class="btn danger" id="stopBoth" disabled>■ Stop</button>
          <span class="tiny" id="recStatus">Not recording</span>
        </div>
      </header>
    </section>
  </div>

<script>
(function(){
  const $ = (sel, el=document)=>el.querySelector(sel);
  const $$ = (sel, el=document)=>[...el.querySelectorAll(sel)];
  const clamp = (v,min,max)=>Math.min(max,Math.max(min,v));

  // Globals
  const globalRate = $('#rate');
  const btnSync = $('#btnSync'), btnBack=$('#btnBack'), btnFwd=$('#btnFwd');
  const autoLoop = $('#autoLoop');
  const recordBothBtn = $('#recordBoth'), stopBothBtn = $('#stopBoth'), recStatus = $('#recStatus');
  const autoPlayAfter = $('#autoPlayAfter'), maxDur = $('#maxDur');
  const panelGrid = $('#panelGrid');

  function timeStep(video, dir=+1){
    const step = 1/60;
    video.pause();
    video.currentTime = clamp(video.currentTime + dir*step, 0, video.duration || 1e9);
  }

  // Camera helpers
  async function listCameras(){
    try{
      // Prompt once so labels are visible
      await navigator.mediaDevices.getUserMedia({video:true, audio:false})
        .then(s=>s.getTracks().forEach(tr=>tr.stop()))
        .catch(()=>{});
      const devices = await navigator.mediaDevices.enumerateDevices();
      return devices.filter(d=>d.kind==='videoinput');
    }catch(e){ console.warn(e); return []; }
  }
  function populateCameraDropdowns(){
    listCameras().then(cams=>{
      $$('.cameraSel').forEach((sel,i)=>{
        sel.innerHTML = '';
        cams.forEach((c, idx)=>{
          const opt = document.createElement('option');
          opt.value = c.deviceId;
          opt.textContent = c.label || `Camera ${idx+1}`;
          sel.appendChild(opt);
        });
        if(cams.length) sel.value = cams[Math.min(i, cams.length-1)].deviceId;
      });
    });
  }

  // Drawing layer (Line / Circle / Off) — red stroke, no fill
  function drawingLayer(overlay){
    const ctx = overlay.getContext('2d');
    const state = { shapes:[], active:null, mode:'off' }; // mode: off|line|circle

    function resize(){
      const r = overlay.getBoundingClientRect();
      overlay.width = Math.max(2, Math.floor(r.width));
      overlay.height = Math.max(2, Math.floor(r.height));
      redraw();
    }
    const ro = new ResizeObserver(resize); ro.observe(overlay);

    function redraw(){
      ctx.clearRect(0,0,overlay.width,overlay.height);
      ctx.lineWidth = 3; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--stroke') || '#ff4b4b';
      for(const s of state.shapes){
        if(s.type==='line'){ ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke(); }
        if(s.type==='circle'){ ctx.beginPath(); ctx.arc(s.c.x, s.c.y, s.r, 0, Math.PI*2); ctx.stroke(); }
      }
      if(state.active){
        ctx.setLineDash([8,6]);
        if(state.active.type==='line'){ ctx.beginPath(); ctx.moveTo(state.active.a.x,state.active.a.y); ctx.lineTo(state.active.b.x,state.active.b.y); ctx.stroke(); }
        if(state.active.type==='circle'){ ctx.beginPath(); ctx.arc(state.active.c.x, state.active.c.y, state.active.r, 0, Math.PI*2); ctx.stroke(); }
        ctx.setLineDash([]);
      }
    }
    function px(ev){
      const r = overlay.getBoundingClientRect();
      const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
      const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
      return { x:(clientX - r.left)/r.width*overlay.width, y:(clientY - r.top)/r.height*overlay.height };
    }
    function onDown(ev){
      if(state.mode==='off') return;
      ev.preventDefault();
      const p = px(ev);
      if(state.mode==='line'){ state.active = {type:'line', a:p, b:p}; }
      if(state.mode==='circle'){ state.active = {type:'circle', c:p, r:0}; }
      redraw();
    }
    function onMove(ev){
      if(!state.active) return;
      const p = px(ev);
      if(state.active.type==='line'){ state.active.b = p; }
      if(state.active.type==='circle'){ const dx=p.x-state.active.c.x, dy=p.y-state.active.c.y; state.active.r=Math.hypot(dx,dy); }
      redraw();
    }
    function onUp(){
      if(!state.active) return;
      if(state.active.type==='line'){ const {a,b}=state.active; if(Math.hypot(a.x-b.x,a.y-b.y)>2) state.shapes.push({type:'line', a,b}); }
      if(state.active.type==='circle'){ if(state.active.r>1) state.shapes.push({type:'circle', c:state.active.c, r:state.active.r}); }
      state.active=null; redraw();
    }

    overlay.addEventListener('pointerdown', onDown);
    overlay.addEventListener('pointermove', onMove);
    overlay.addEventListener('pointerup', onUp);
    overlay.addEventListener('pointerleave', onUp);
    overlay.addEventListener('touchstart', onDown, {passive:false});
    overlay.addEventListener('touchmove', onMove, {passive:false});
    overlay.addEventListener('touchend', onUp);

    function setMode(m){ state.mode = m; }
    function clear(){ state.shapes.length=0; state.active=null; redraw(); }

    resize();
    return { setMode, clear, redraw, state };
  }

  // Panel init
  function initPanel(panel){
    const video = $('.vid', panel);
    const overlay = $('.overlay', panel);
    const file = $('.file', panel);
    const btnPlay = $('[data-play]', panel);
    const btnPause = $('[data-pause]', panel);
    const btnBack = $('[data-back]', panel);
    const btnFwd = $('[data-fwd]', panel);
    const btnClear = $('[data-clear]', panel);
    const rateLabel = $('.rate', panel);
    const rateSlider = $('[data-rate]', panel);
    const btnCam = $('[data-cam]', panel);
    const camSel = $('.cameraSel', panel);
    const drawSel = $('.drawMode', panel);
    const btnRec = $('[data-rec]', panel);
    const btnStop = $('[data-stop]', panel);
    const recStatus = $('.recStatus', panel);

    // Drawing API
    const drawAPI = drawingLayer(overlay);
    drawSel.addEventListener('change', ()=>drawAPI.setMode(drawSel.value));

    // Upload
    file?.addEventListener('change', e=>{
      const f = e.target.files[0]; if(!f) return;
      const url = URL.createObjectURL(f);
      video.srcObject = null; video.src = url; video.loop = autoLoop.checked; video.load();
    });

    // Camera preview
    let currentStream = null;
    async function startCam(){
      try{
        const id = camSel?.value;
        const constraints = {video: id ? {deviceId:{exact:id}, width:{ideal:1920}, height:{ideal:1080}} : {width:{ideal:1920}, height:{ideal:1080}}, audio:false};
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        if(currentStream) currentStream.getTracks().forEach(t=>t.stop());
        currentStream = stream;
        video.srcObject = stream; video.muted = true; await video.play();
        panel.__player.stream = stream;
      }catch(err){ console.error(err); alert('Camera not available or permission denied.'); }
    }
    btnCam?.addEventListener('click', startCam);

    // Controls
    btnPlay.addEventListener('click', ()=>video.play());
    btnPause.addEventListener('click', ()=>video.pause());
    btnBack.addEventListener('click', ()=>timeStep(video, -1));
    btnFwd.addEventListener('click', ()=>timeStep(video, +1));

    // Rate
    function applyGlobalRate(){ const r = parseFloat(globalRate.value); video.playbackRate=r; rateSlider.value=r; rateLabel.textContent=r.toFixed(2)+'x'; }
    applyGlobalRate();
    rateSlider.addEventListener('input', ()=>{ video.playbackRate = parseFloat(rateSlider.value); rateLabel.textContent = video.playbackRate.toFixed(2)+'x'; });

    // Per-panel recording
    let rec=null, chunks=[];
    function makeRecorder(stream, ondata){
      const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9'
                 : MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8'
                 : 'video/webm';
      const r = new MediaRecorder(stream, {mimeType:mime, videoBitsPerSecond: 6_000_000});
      r.ondataavailable = e=>{ if(e.data && e.data.size) ondata(e.data); };
      return r;
    }
    btnRec.addEventListener('click', async ()=>{
      try{
        if(!panel.__player.stream) await startCam();
        chunks=[]; rec = makeRecorder(panel.__player.stream, d=>chunks.push(d));
        rec.onstart = ()=>{ btnRec.disabled=true; btnStop.disabled=false; recStatus.textContent='Recording…'; };
        rec.onstop = ()=>{
          btnRec.disabled=false; btnStop.disabled=true; recStatus.textContent='Idle';
          const blob = new Blob(chunks, {type: chunks[0]?.type || 'video/webm'});
          const url = URL.createObjectURL(blob);
          video.srcObject = null; video.src = url; video.loop = autoLoop.checked; video.load(); video.currentTime=0; video.play();
        };
        rec.start();
      }catch(e){ console.error(e); alert('Unable to start recording.'); }
    });
    btnStop.addEventListener('click', ()=>{ try{ rec && rec.state!=='inactive' && rec.stop(); }catch{} });

    // Expose
    panel.__player = {
      video, overlay, drawAPI, stream:null, startCam, camSel,
      setRate:(r)=>{ video.playbackRate=r; rateSlider.value=r; rateLabel.textContent=r.toFixed(2)+'x'; },
      step:(d)=>timeStep(video,d)
    };

    // Clear drawings
    btnClear.addEventListener('click', ()=>drawAPI.clear());
  }

  // Initialize panels
  $$('.panel[data-role="player"]').forEach(initPanel);
  populateCameraDropdowns();

  // Global controls
  globalRate.addEventListener('input', ()=>{
    const r = parseFloat(globalRate.value);
    $$('.panel[data-role="player"]').forEach(p=>p.__player?.setRate(r));
  });
  $('#ctaStart').addEventListener('click', ()=>panelGrid.scrollIntoView({behavior:'smooth'}));
  btnSync.addEventListener('click', ()=>{
    const vids = $$('.panel[data-role="player"] .vid');
    const playAll = vids.some(v=>v.paused);
    vids.forEach(v=>{ v.loop = autoLoop.checked; playAll ? v.play() : v.pause(); });
  });
  btnBack.addEventListener('click', ()=>{$$('.panel[data-role="player"]').forEach(p=>p.__player?.step(-1));});
  btnFwd.addEventListener('click', ()=>{$$('.panel[data-role="player"]').forEach(p=>p.__player?.step(+1));});

  // Record both (sync)
  let recA=null, recB=null, chunksA=[], chunksB=[], recTimer=null;
  async function ensureStreams(){
    const panels = [$('#panelA'), $('#panelB')];
    for(const p of panels){ if(!p.__player.stream){ await p.__player.startCam(); } }
  }
  function makeRecorder(stream, ondata){
    const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9'
               : MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8'
               : 'video/webm';
    const rec = new MediaRecorder(stream, {mimeType:mime, videoBitsPerSecond: 6_000_000});
    rec.ondataavailable = e=>{ if(e.data && e.data.size) ondata(e.data); };
    return rec;
  }
  function setBothUI(active){
    recordBothBtn.disabled = active; stopBothBtn.disabled = !active;
    recStatus.textContent = active ? 'Recording…' : 'Not recording';
  }
  async function startBoth(){
    await ensureStreams();
    const pA = $('#panelA').__player, pB = $('#panelB').__player;
    chunksA=[]; chunksB=[];
    recA = makeRecorder(pA.stream, d=>chunksA.push(d));
    recB = makeRecorder(pB.stream, d=>chunksB.push(d));
    recA.start(); recB.start();
    setBothUI(true);
    const dur = clamp(parseFloat(maxDur.value)||8, 1, 120);
    recTimer = setTimeout(stopBoth, dur*1000);
  }
  function blobToVideo(video, blob){
    const url = URL.createObjectURL(blob);
    video.srcObject = null; video.src = url; video.loop = autoLoop.checked; video.load();
  }
  function syncAndPlay(){
    const vA = $('#panelA').__player.video;
    const vB = $('#panelB').__player.video;
    const startWhenReady = ()=>{
      if(Number.isFinite(vA.duration) && vA.duration>0 && Number.isFinite(vB.duration) && vB.duration>0){
        vA.currentTime=0; vB.currentTime=0;
        const r = parseFloat(globalRate.value);
        vA.playbackRate=r; vB.playbackRate=r;
        if(autoPlayAfter.checked){ vA.play(); vB.play(); }
      }else{ setTimeout(startWhenReady, 60); }
    };
    startWhenReady();
  }
  function stopBoth(){
    try{ recA && recA.state!=='inactive' && recA.stop(); }catch{}
    try{ recB && recB.state!=='inactive' && recB.stop(); }catch{}
    clearTimeout(recTimer); recTimer=null; setBothUI(false);

    const done={};
    const finish=()=>{
      if(done.a && done.b){
        const vA = $('#panelA').__player.video, vB = $('#panelB').__player.video;
        const blobA = new Blob(chunksA, {type: chunksA[0]?.type || 'video/webm'});
        const blobB = new Blob(chunksB, {type: chunksB[0]?.type || 'video/webm'});
        blobToVideo(vA, blobA); blobToVideo(vB, blobB); syncAndPlay();
      }
    };
    if(recA) recA.onstop = ()=>{ done.a=true; finish(); };
    if(recB) recB.onstop = ()=>{ done.b=true; finish(); };
  }
  recordBothBtn.addEventListener('click', startBoth);
  stopBothBtn.addEventListener('click', stopBoth);

  // Keyboard shortcuts
  document.addEventListener('keydown', (e)=>{
    if(e.target && ['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;
    if(e.code==='Space'){ e.preventDefault(); btnSync.click(); }
    if(e.key===',' ){ e.preventDefault(); btnBack.click(); }
    if(e.key==='.' ){ e.preventDefault(); btnFwd.click(); }
  });
})();
</script>
</body>
</html>
